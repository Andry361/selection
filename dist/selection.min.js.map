{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/utils.js","webpack:///./src/selection.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","eventListener","method","elements","events","fn","options","arguments","length","undefined","HTMLCollection","NodeList","Array","from","isArray","element","event","_objectSpread","capture","slice","on","off","unitify","val","unit","css","el","attr","style","prop","dw","document","defaultView","getComputedStyle","currentStyle","intersects","a","b","rectA","rectB","mapRectToArrayCoordinate","polygons","minA","maxA","projected","minB","maxB","polygon","i1","i2","p1","p2","normal","x","y","j","isUndefined","doPolygonsIntersect","left","top","right","bottom","rect","_rect$getBoundingClie","getBoundingClientRect","width","height","selectAll","selector","nodes","sel","push","querySelectorAll","eventPath","evt","path","composedPath","target","parentElement","removeElement","arr","index","indexOf","splice","simplifyEvent","tap","touches","clientX","clientY","abs","Math","max","min","round","doc","preventDefault","e","Selection","that","assign","class","startThreshold","singleClick","disableTouch","validateStart","containers","selectables","scrollSpeedDivider","startareas","boundaries","_selectedStore","_areaElement","createElement","_clippingElement","_scrollAvailable","_scrollSpeed","_scrollActive","_init","appendChild","body","_","position","overflow","transform","pointer-events","enable","_bindStartEvents","type","_onTapStart","passive","_$simplifyEvent","targetBoundingClientRect","startAreas","_boundaries","evtpath","find","includes","_areaX1","_areaY1","_areaX2","_areaY2","_singleClick","resolveSelectables","_targetContainer","_targetBoundary","_touchedElements","_changedElements","added","removed","scrollHeight","_manualScroll","_selectables","filter","contains","margin-top","margin-left","classList","add","_delayedTapMove","_onTapStop","_onSingleTap","_dispatchEvent","_$simplifyEvent3","_onTapMove","_$simplifyEvent4","scon","requestAnimationFrame","scroll","initial","scrollTop","ceil","_redrawArea","_updatedTouchingElements","wheelDelta","brect","x3","y3","x4","y4","noevent","touched","changed","areaRect","node","_dispatchFilterEvent","eventName","selection","originalEvent","additional","selection_objectSpread","areaElement","selectedElements","concat","changedElements","keepSelection","clearSelection","removeFromSelection","getSelection","cancel","keepEvent","option","disable","destroy","removeChild","utils","version"],"mappings":"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","file":"selection.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Selection\"] = factory();\n\telse\n\t\troot[\"Selection\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","function eventListener(method, elements, events, fn, options = {}) {\r\n\r\n    // Normalize array\r\n    if (elements instanceof HTMLCollection || elements instanceof NodeList) {\r\n        elements = Array.from(elements);\r\n    } else if (!Array.isArray(elements)) {\r\n        elements = [elements];\r\n    }\r\n\r\n    if (!Array.isArray(events)) events = [events];\r\n\r\n    for (const element of elements) {\r\n        for (const event of events) {\r\n            element[method](event, fn, {capture: false, ...options});\r\n        }\r\n    }\r\n\r\n    return Array.prototype.slice.call(arguments, 1);\r\n}\r\n\r\n/**\r\n * Add event(s) to element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const on = eventListener.bind(null, 'addEventListener');\r\n\r\n/**\r\n * Remove event(s) from element(s).\r\n * @param elements DOM-Elements\r\n * @param events Event names\r\n * @param fn Callback\r\n * @param options Optional options\r\n * @return Array passed arguments\r\n */\r\nexport const off = eventListener.bind(null, 'removeEventListener');\r\n\r\nconst unitify = (val, unit = 'px') => typeof val === 'number' ? val + unit : '' + val;\r\n\r\n/**\r\n * Add css to a DOM-Element or returns the current\r\n * value of a property.\r\n *\r\n * @param el The Element.\r\n * @param attr The attribute or a object which holds css key-properties.\r\n * @param val The value for a single attribute.\r\n * @returns {*}\r\n */\r\nexport function css(el, attr, val) {\r\n    const style = el && el.style;\r\n    if (!style) return;\r\n\r\n    if (typeof attr === 'object') {\r\n\r\n        for (const prop in attr) {\r\n            style[prop] = unitify(attr[prop]);\r\n        }\r\n\r\n    } else if (val == null) {\r\n\r\n        const dw = document.defaultView;\r\n        if (dw && dw.getComputedStyle) {\r\n            val = dw.getComputedStyle(el, null);\r\n        } else if (el.currentStyle) {\r\n            val = el.currentStyle;\r\n        }\r\n\r\n        return attr == null ? val : val[attr];\r\n    } else {\r\n        style[attr] = unitify(val);\r\n    }\r\n}\r\n\r\n/**\r\n * Check if two DOM-Elements intersects each other.\r\n * @param a BoundingClientRect of the first element.\r\n * @param b BoundingClientRect of the second element.\r\n * @param mode Options are center, cover or touch.\r\n * @returns {boolean} If both elements intersects each other.\r\n */\r\nexport function intersects(a, b, mode = 'touch') {\r\n\r\n    if (mode === 'center') {\r\n        return doPolygonsIntersect(a, b);\r\n    } else if (mode === 'cover') {\r\n        return b.left >= a.left\r\n            && b.top >= a.top\r\n            && b.right <= a.right\r\n            && b.bottom <= a.bottom;\r\n    } else if (mode === 'touch') {\r\n        return a.right >= b.left\r\n            && a.left <= b.right\r\n            && a.bottom >= b.top\r\n            && a.top <= b.bottom;\r\n    }\r\n}\r\n\r\nfunction isUndefined(a) {\r\n    return a === undefined;\r\n}\r\n\r\n/**\r\n * Helper function to determine whether there is an intersection between the two polygons described\r\n * by the lists of vertices. Uses the Separating Axis Theorem\r\n *\r\n * @param a an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @param b an array of connected points [{x:, y:}, {x:, y:},...] that form a closed polygon\r\n * @return true if there is any intersection between the 2 polygons, false otherwise\r\n */\r\nfunction doPolygonsIntersect (rectA, rectB) {\r\n    const a = mapRectToArrayCoordinate(rectA);\r\n    const b = mapRectToArrayCoordinate(rectB);\r\n    const polygons = [a, b];\r\n    let minA, maxA, projected, minB, maxB;\r\n\r\n    for (let i = 0; i < polygons.length; i++) {\r\n\r\n        // for each polygon, look at each edge of the polygon, and determine if it separates\r\n        // the two shapes\r\n        let polygon = polygons[i];\r\n        for (let i1 = 0; i1 < polygon.length; i1++) {\r\n\r\n            // grab 2 vertices to create an edge\r\n            let i2 = (i1 + 1) % polygon.length;\r\n            let p1 = polygon[i1];\r\n            let p2 = polygon[i2];\r\n\r\n            // find the line perpendicular to this edge\r\n            let normal = { x: p2.y - p1.y, y: p1.x - p2.x };\r\n\r\n            minA = maxA = undefined;\r\n            // for each vertex in the first shape, project it onto the line perpendicular to the edge\r\n            // and keep track of the min and max of these values\r\n            for (let j = 0; j < a.length; j++) {\r\n                projected = normal.x * a[j].x + normal.y * a[j].y;\r\n                if (isUndefined(minA) || projected < minA) {\r\n                    minA = projected;\r\n                }\r\n                if (isUndefined(maxA) || projected > maxA) {\r\n                    maxA = projected;\r\n                }\r\n            }\r\n\r\n            // for each vertex in the second shape, project it onto the line perpendicular to the edge\r\n            // and keep track of the min and max of these values\r\n            minB = maxB = undefined;\r\n            for (let j = 0; j < b.length; j++) {\r\n                projected = normal.x * b[j].x + normal.y * b[j].y;\r\n                if (isUndefined(minB) || projected < minB) {\r\n                    minB = projected;\r\n                }\r\n                if (isUndefined(maxB) || projected > maxB) {\r\n                    maxB = projected;\r\n                }\r\n            }\r\n\r\n            // if there is no overlap between the projects, the edge we are looking at separates the two\r\n            // polygons, and we know there is no overlap\r\n            if (maxA < minB || maxB < minA) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction mapRectToArrayCoordinate(rect) {\r\n    const { x , y, width, height } = rect.getBoundingClientRect()\r\n    return [\r\n        { x, y }, // left-top\r\n        { x: x + width, y }, // right-top\r\n        { x: x + width, y: y + height  }, // right-bottom\r\n        { x, y: y + height  }, // left-bottom\r\n    ];\r\n}\r\n\r\n/**\r\n * Takes a selector (or array of selectors) and returns the matched nodes.\r\n * @param selector The selector or an Array of selectors.\r\n * @returns {Array} Array of DOM-Nodes.\r\n */\r\nexport function selectAll(selector) {\r\n    if (!Array.isArray(selector)) selector = [selector];\r\n\r\n    const nodes = [];\r\n    for (const sel of selector) {\r\n        nodes.push(...document.querySelectorAll(sel));\r\n    }\r\n\r\n    return nodes;\r\n}\r\n\r\n/**\r\n * Polyfill for safari & firefox for the eventPath event property.\r\n * @param evt The event object.\r\n * @return [String] event path.\r\n */\r\nexport function eventPath(evt) {\r\n    let path = evt.path || (evt.composedPath && evt.composedPath());\r\n    if (path) return path;\r\n\r\n    let el = evt.target.parentElement;\r\n    path = [evt.target, el];\r\n    while (el = el.parentElement) path.push(el);\r\n\r\n    path.push(document, window);\r\n    return path;\r\n}\r\n\r\n/**\r\n * Removes an element from an Array.\r\n */\r\nexport function removeElement(arr, el) {\r\n    const index = arr.indexOf(el);\r\n    if (~index) arr.splice(index, 1);\r\n}\r\n\r\nexport function simplifyEvent(evt) {\r\n    const tap = (evt.touches && evt.touches[0] || evt);\r\n    return {\r\n        tap,\r\n        x: tap.clientX,\r\n        y: tap.clientY,\r\n        target: tap.target\r\n    };\r\n}","/**\r\n * Selection, library to realize visual DOM-Selection like on your Desktop.\r\n *\r\n * @author  Simon Reinisch\r\n * @license MIT\r\n */\r\n\r\n// Import utils\r\nimport * as _ from './utils';\r\n\r\n// Some var shorting for better compression and readability\r\nconst {abs, max, min, round} = Math;\r\nconst doc = document;\r\nconst preventDefault = e => e.preventDefault();\r\n\r\nfunction Selection(options = {}) {\r\n\r\n    const that = {\r\n\r\n        options: Object.assign({\r\n            class: 'selection-area',\r\n\r\n            mode: 'touch',\r\n            startThreshold: 10,\r\n            singleClick: true,\r\n            disableTouch: false,\r\n\r\n            validateStart: () => true,\r\n\r\n            containers: [],\r\n            selectables: [],\r\n\r\n            scrollSpeedDivider: 10,\r\n\r\n            startareas: ['html'],\r\n            boundaries: ['html']\r\n        }, options),\r\n\r\n        // Store for keepSelection\r\n        _selectedStore: [],\r\n\r\n        // Create area element\r\n        _areaElement: doc.createElement('div'),\r\n        _clippingElement: doc.createElement('div'),\r\n\r\n        // Is getting set on movement. Varied.\r\n        _scrollAvailable: true,\r\n        _scrollSpeed: null,\r\n        _scrollActive: false,\r\n\r\n        _init() {\r\n\r\n            // Append area to body\r\n            that._clippingElement.appendChild(that._areaElement);\r\n            doc.body.appendChild(that._clippingElement);\r\n\r\n            // Apply basic styles to the area element\r\n            _.css(that._areaElement, {\r\n                top: 0,\r\n                left: 0,\r\n                position: 'fixed'\r\n            });\r\n\r\n            _.css(that._clippingElement, {\r\n                overflow: 'hidden',\r\n                position: 'fixed',\r\n                transform: 'translate3d(0, 0, 0)', // https://stackoverflow.com/a/38268846\r\n                'pointer-events': 'none'\r\n            });\r\n\r\n            that.enable();\r\n        },\r\n\r\n        _bindStartEvents(type) {\r\n            _[type](doc, 'mousedown', that._onTapStart);\r\n\r\n            if (!that.options.disableTouch) {\r\n                _[type](doc, 'touchstart', that._onTapStart, {\r\n                    passive: false\r\n                });\r\n            }\r\n        },\r\n\r\n        _onTapStart(evt) {\r\n            const {x, y, target} = _.simplifyEvent(evt);\r\n            const targetBoundingClientRect = target.getBoundingClientRect();\r\n\r\n            // Check mouse middleware\r\n            if (!that.options.validateStart(evt)) {\r\n                return;\r\n            }\r\n\r\n            // Find start-areas and boundaries\r\n            const startAreas = _.selectAll(that.options.startareas);\r\n            that._boundaries = _.selectAll(that.options.boundaries);\r\n\r\n            // Check if area starts in one of the start areas / boundaries\r\n            const evtpath = _.eventPath(evt);\r\n            if (!startAreas.find(el => evtpath.includes(el)) ||\r\n                !that._boundaries.find(el => evtpath.includes(el))) {\r\n                return;\r\n            }\r\n\r\n            // Area start point\r\n            that._areaX1 = x;\r\n            that._areaY1 = y;\r\n\r\n            // Area end point\r\n            that._areaX2 = 0;\r\n            that._areaY2 = 0;\r\n\r\n            that._singleClick = true; // To detect single-click\r\n\r\n            that.resolveSelectables();\r\n\r\n            // Check in which container the user currently acts\r\n            that._targetContainer = that._boundaries.find(el =>\r\n                _.intersects(el.getBoundingClientRect(), targetBoundingClientRect)\r\n            );\r\n\r\n            // Just saving the boundaries of this container for later\r\n            that._targetBoundary = that._targetContainer.getBoundingClientRect();\r\n            that._touchedElements = [];\r\n            that._changedElements = {\r\n                added: [],\r\n                removed: []\r\n            };\r\n\r\n            // Find container and check if it's scrollable\r\n            if (round(that._targetContainer.scrollHeight) !== round(that._targetBoundary.height)) {\r\n\r\n                // Indenticates if the user is currently in a scrollable area\r\n                that._scrollAvailable = true;\r\n\r\n                // Detect mouse scrolling\r\n                _.on(window, 'wheel', that._manualScroll);\r\n\r\n                /**\r\n                 * The selection-area will also cover other element which are\r\n                 * out of the current scrollable parent. So find all elements\r\n                 * which are in the current scrollable element. Later these are\r\n                 * the only selectables instead of all.\r\n                 */\r\n                that._selectables = that._selectables.filter(s => that._targetContainer.contains(s));\r\n\r\n                /**\r\n                 * To clip the area, the selection area has a parent\r\n                 * which has exact the same dimensions as the scrollable elemeent.\r\n                 * Now if the area exeeds these boundaries it will be cropped.\r\n                 */\r\n                _.css(that._clippingElement, {\r\n                    top: that._targetBoundary.top,\r\n                    left: that._targetBoundary.left,\r\n                    width: that._targetBoundary.width,\r\n                    height: that._targetBoundary.height\r\n                });\r\n\r\n                /**\r\n                 * The area element is relative to the clipping element,\r\n                 * but when this is moved or transformed we need to correct\r\n                 * the positions via a negative margin.\r\n                 */\r\n                _.css(that._areaElement, {\r\n                    'margin-top': -that._targetBoundary.top,\r\n                    'margin-left': -that._targetBoundary.left\r\n                });\r\n            } else {\r\n                that._scrollAvailable = false;\r\n\r\n                /**\r\n                 * Reset margin and clipping element dimensions.\r\n                 */\r\n                _.css(that._clippingElement, {\r\n                    top: 0,\r\n                    left: 0,\r\n                    width: '100%',\r\n                    height: '100%'\r\n                });\r\n\r\n                _.css(that._areaElement, {\r\n                    'margin-top': 0,\r\n                    'margin-left': 0\r\n                });\r\n            }\r\n\r\n            // Add class to the area element\r\n            that._areaElement.classList.add(that.options.class);\r\n\r\n            // Prevent default select event\r\n            _.on(doc, 'selectstart', preventDefault);\r\n\r\n            // Add listener\r\n            _.on(doc, 'mousemove', that._delayedTapMove);\r\n            _.on(doc, 'touchmove', that._delayedTapMove, {\r\n                passive: false\r\n            });\r\n\r\n            _.on(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _onSingleTap(evt) {\r\n            let {target} = _.simplifyEvent(evt);\r\n\r\n            // Traverse dom upwards to check if target is selectable\r\n            while (!that._selectables.includes(target)) {\r\n                if (target.parentElement) {\r\n                    target = target.parentElement;\r\n                } else {\r\n                    return;\r\n                }\r\n            }\r\n\r\n            that._touchedElements.push(target);\r\n            that._dispatchEvent('onSelect', evt, {\r\n                target\r\n            });\r\n        },\r\n\r\n        _delayedTapMove(evt) {\r\n            const {x, y} = _.simplifyEvent(evt);\r\n\r\n            // Check pixel threshold\r\n            if (abs((x + y) - (that._areaX1 + that._areaY1)) >= that.options.startThreshold) {\r\n\r\n                _.off(doc, ['mousemove', 'touchmove'], that._delayedTapMove);\r\n                _.on(doc, ['mousemove', 'touchmove'], that._onTapMove);\r\n                _.css(that._areaElement, 'display', 'block');\r\n\r\n                // New start position\r\n                that._onTapMove(evt);\r\n\r\n                // Fire event\r\n                that._dispatchEvent('onStart', evt);\r\n\r\n                // An action is recognized as single-select until\r\n                // the user performed a mutli-selection\r\n                that._singleClick = false;\r\n            }\r\n        },\r\n\r\n        _onTapMove(evt) {\r\n            const {x, y} = _.simplifyEvent(evt);\r\n            that._areaX2 = x;\r\n            that._areaY2 = y;\r\n\r\n            if (that._scrollAvailable && !that._scrollActive && that._scrollSpeed !== null) {\r\n                const scon = that._targetContainer;\r\n\r\n                // Prevent multiple requestAnimationFrame callbacks\r\n                that._scrollActive = true;\r\n\r\n                // Continous scrolling\r\n                requestAnimationFrame(function scroll() {\r\n\r\n                    // Scrolling is not anymore required\r\n                    if (that._scrollSpeed === null) {\r\n                        return (that._scrollActive = false);\r\n                    }\r\n\r\n                    /**\r\n                     * If the value exeeds the scrollable area it will\r\n                     * be set to the max / min value. So change only\r\n                     */\r\n                    const initial = scon.scrollTop;\r\n\r\n                    // Reduce velocity, use ceil to scroll at least 1px per frame\r\n                    scon.scrollTop += Math.ceil(that._scrollSpeed / that.options.scrollSpeedDivider);\r\n                    that._areaY1 -= scon.scrollTop - initial;\r\n\r\n                    /**\r\n                     * We changed the start coordinates ->  redraw the selectiona area\r\n                     * We changed the dimensions of the area element -> re-calc selected elements\r\n                     * The selected elements array has been changed -> fire event\r\n                     */\r\n                    that._redrawArea();\r\n                    that._updatedTouchingElements();\r\n                    that._dispatchEvent('onMove', evt);\r\n\r\n                    // Keep scrolling even if the user stops to move his pointer\r\n                    requestAnimationFrame(scroll);\r\n                });\r\n            } else {\r\n\r\n                /**\r\n                 * Perform redraw only if scrolling is not active.\r\n                 * If scrolling is active this area is getting re-dragwed by the\r\n                 * anonymized scroll function.\r\n                 */\r\n                that._redrawArea();\r\n                that._updatedTouchingElements();\r\n                that._dispatchEvent('onMove', evt);\r\n            }\r\n        },\r\n\r\n        _manualScroll(evt) {\r\n            that._scrollSpeed += that.options.scrollSpeedDivider * (evt.wheelDelta * -1);\r\n            that._onTapMove(evt);\r\n\r\n            // Prevent defaul scrolling behaviour, eg. page scrolling\r\n            evt.preventDefault();\r\n        },\r\n\r\n        _redrawArea() {\r\n            const brect = that._targetBoundary;\r\n            let x = that._areaX2;\r\n            let y = that._areaY2;\r\n\r\n            if (x < brect.left) {\r\n                x = brect.left;\r\n            } else if (x > brect.left + brect.width) {\r\n                x = brect.left + brect.width;\r\n            }\r\n\r\n            if (y < brect.top) {\r\n                that._scrollSpeed = -Math.abs(brect.top - y);\r\n                y = brect.top;\r\n            } else if (y > brect.top + brect.height) {\r\n                that._scrollSpeed = Math.abs(brect.top + brect.height - y);\r\n                y = brect.top + brect.height;\r\n            } else {\r\n                that._scrollSpeed = null;\r\n            }\r\n\r\n            const x3 = min(that._areaX1, x);\r\n            const y3 = min(that._areaY1, y);\r\n            const x4 = max(that._areaX1, x);\r\n            const y4 = max(that._areaY1, y);\r\n\r\n            _.css(that._areaElement, {\r\n                top: y3,\r\n                left: x3,\r\n                width: x4 - x3,\r\n                height: y4 - y3\r\n            });\r\n        },\r\n\r\n        _onTapStop(evt, noevent) {\r\n\r\n            // Remove event handlers\r\n            _.off(doc, ['mousemove', 'touchmove'], that._delayedTapMove);\r\n            _.off(doc, ['touchmove', 'mousemove'], that._onTapMove);\r\n            _.off(doc, ['mouseup', 'touchcancel', 'touchend'], that._onTapStop);\r\n\r\n            if (that._singleClick && that.options.singleClick) {\r\n                that._onSingleTap(evt);\r\n            } else if (!that._singleClick && !noevent) {\r\n                that._updatedTouchingElements();\r\n                that._dispatchEvent('onStop', evt);\r\n            }\r\n\r\n            // Reset scroll speed\r\n            that._scrollSpeed = null;\r\n\r\n            // Unbind mouse scrolling listener\r\n            _.off(window, 'wheel', that._manualScroll);\r\n\r\n            // Enable default select event\r\n            _.off(doc, 'selectstart', preventDefault);\r\n            _.css(that._areaElement, 'display', 'none');\r\n        },\r\n\r\n        _updatedTouchingElements() {\r\n            const touched = [];\r\n            const changed = {added: [], removed: []};\r\n\r\n            const mode = that.options.mode;\r\n            const selectables = that._selectables;\r\n            const areaRect = that._areaElement.getBoundingClientRect();\r\n\r\n            // Itreate over the selectable elements\r\n            for (let i = 0, n = selectables.length, node; node = selectables[i], i < n; i++) {\r\n\r\n                // Check if area intersects element\r\n                if (_.intersects(areaRect, node.getBoundingClientRect(), mode)) {\r\n\r\n                    // Fire filter event\r\n                    if (that._dispatchFilterEvent('selectionFilter', node) !== false) {\r\n\r\n                        // Check if the element wasn't present in the last selection.\r\n                        if (!that._touchedElements.includes(node)) {\r\n                            changed.added.push(node);\r\n                        }\r\n\r\n                        touched.push(node);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Check which elements where removed since last selection\r\n            for (let i = 0, n = that._touchedElements.length, el; el = that._touchedElements[i], i < n; i++) {\r\n                if (!touched.includes(el)) {\r\n                    changed.removed.push(el);\r\n                }\r\n            }\r\n\r\n            // Save\r\n            that._touchedElements = touched;\r\n            that._changedElements = changed;\r\n        },\r\n\r\n        _dispatchFilterEvent(eventName, element) {\r\n            const event = that.options[eventName];\r\n\r\n            // Validate function\r\n            if (typeof event === 'function') {\r\n                return event.call(that, {selection: that, eventName, element});\r\n            }\r\n        },\r\n\r\n        _dispatchEvent(eventName, originalEvent, additional) {\r\n            const event = that.options[eventName];\r\n\r\n            // Validate function\r\n            if (typeof event === 'function') {\r\n                return event.call(that, {\r\n                    selection: that,\r\n                    areaElement: that._areaElement,\r\n                    selectedElements: that._touchedElements.concat(that._selectedStore),\r\n                    changedElements: that._changedElements,\r\n                    eventName,\r\n                    originalEvent,\r\n                    ...additional\r\n                });\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Can be used if during a selection elements have been added.\r\n         * Will update everything which can be selected.\r\n         */\r\n        resolveSelectables() {\r\n\r\n            // Resolve selectors\r\n            that._selectables = _.selectAll(that.options.selectables);\r\n            const containers = _.selectAll(that.options.containers);\r\n            for (let i = 0, n = containers.length; i < n; i++) {\r\n                that._selectables.push(...containers[i].querySelectorAll('*'));\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Saves the current selection for the next selecion.\r\n         * Allows multiple selections.\r\n         */\r\n        keepSelection() {\r\n            for (let i = 0, n = that._touchedElements.length, el; el = that._touchedElements[i], i < n; i++) {\r\n                if (!that._selectedStore.includes(el)) {\r\n                    that._selectedStore.push(el);\r\n                }\r\n            }\r\n        },\r\n\r\n        /**\r\n         * Clear the elements which where saved by 'keepSelection()'.\r\n         */\r\n        clearSelection() {\r\n            that._selectedStore = [];\r\n        },\r\n\r\n        /**\r\n         * Removes an particular element from the selection.\r\n         */\r\n        removeFromSelection(el) {\r\n            _.removeElement(that._selectedStore, el);\r\n            _.removeElement(that._touchedElements, el);\r\n        },\r\n\r\n        /**\r\n         * @returns {Array} Selected elements\r\n         */\r\n        getSelection() {\r\n            return that._selectedStore;\r\n        },\r\n\r\n        /**\r\n         * Cancel the current selection process.\r\n         * @param keepEvent {boolean} true to fire the onStop listener after cancel.\r\n         */\r\n        cancel(keepEvent = false) {\r\n            that._onTapStop(null, !keepEvent);\r\n        },\r\n\r\n        /**\r\n         * Set or get an option.\r\n         * @param   {string} name\r\n         * @param   {*}      value\r\n         * @return  {*}      the new value\r\n         */\r\n        option(name, value) {\r\n            const {options} = that;\r\n            return value == null ? options[name] : (options[name] = value);\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        disable() {\r\n            that._bindStartEvents('off');\r\n        },\r\n\r\n        /**\r\n         * Unbinds all events and removes the area-element\r\n         */\r\n        destroy() {\r\n            that.disable();\r\n            doc.body.removeChild(that._clippingElement);\r\n        },\r\n\r\n        /**\r\n         * Disable the selection functinality.\r\n         */\r\n        enable() {\r\n            that._bindStartEvents('on');\r\n        }\r\n    };\r\n\r\n    // Initialize\r\n    that._init();\r\n\r\n    return that;\r\n}\r\n\r\n// Export utils\r\nSelection.utils = {\r\n    on: _.on,\r\n    off: _.off,\r\n    css: _.css,\r\n    intersects: _.intersects,\r\n    selectAll: _.selectAll,\r\n    eventPath: _.eventPath,\r\n    removeElement: _.removeElement\r\n};\r\n\r\n/**\r\n * Create selection instance\r\n * @param {Object} [options]\r\n */\r\nSelection.create = options => new Selection(options);\r\n\r\n// Set version\r\nSelection.version = '0.2.0';\r\n\r\n// Export API\r\nexport default Selection;\r\n"],"sourceRoot":""}